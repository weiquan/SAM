import re
import sys
import getopt
import const


def usage():
    usage_wgsim_alnEval = '''
    Usage:          aln_eval.py     wgsim     [opt]   <samfile>
    opt:            -h/--help       help 
                    -u  str         print unmapped reads to file with name str
                    -m  str         print mapped reads to file with name str'''
    print >>sys.err, usage_wgsim_alnEval


def parseWgsimAnswer(seqName):
    pattern = re.compile(r'_\d+_\d+_')
    match = pattern.search(seqName)
    if match == None:
        print >>sys.err, 'seq ' + seqName + "is not generated by wgsim!"
        exit(1);
    chrome = seqName[:match.start()]
    posLeft, posRight = seqName[match.start()+1:match.end()-1].split('_')
    posLeft = long(posLeft)
    posRight = long(posRight)
    return chrome, posLeft, posRight
def evalWgsimSeq(samLine, statDic, optDic):
        sam = samLine.split('\t')
        seqName, flag, ref, pos, Mapq, cigar, mateRef, matePos, templateLen, seq, qual = sam[:11]
        flag = int(flag)
        pos = long(pos)
        #templateLen = int(templateLen)
        templateLen = 100
        answerChr, answerLeftPos, answerRightPos = parseWgsimAnswer(seqName)
        if flag & const.FLAG_UNMAP != 0:
            statDic['unmappedReadsNum'] += 1
            return const.UHIT 
        else:
            statDic['mappedReadsNum'] += 1
            if ref == answerChr:#same chrome
                if flag & const.FLAG_REVERSE == 0:
                    if pos == answerLeftPos:
                        statDic['perfectAlnNum'] += 1
                    return const.PHIT
                else:
                    if pos == answerRightPos - templateLen+1:
                        statDic['perfectAlnNum'] += 1
                    return const.PHIT
def wgsim_alnEval(arg):

    optDic = {'OutPutMapped':False, 'OutPutUnMapped':False}
    statDic = {'unmappedReadsNum':0, 'mappedReadsNum':0, 'perfectAlnNum':0}
    #parse opt
    try:
        opts, args = getopt.getopt(arg[1:], "hu:",['help', 'wgsim'])
    except getopt.GetoptError as err:
        print >>sys.stderr, str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)

    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in('-u'):
            optDic['OutPutUnMapped'] = True #output unmapped
            fpUnmapped = open(a, 'w')
        elif o in('-m'):
            optDic['OutPutMapped'] = True #output mapped
            fpMapped = open(a, 'w')
        else:
            assert False, "unhandled option"
    # ...
    if len(args) != 1:
        usage()
        exit(1)
    samFileName = args[0]

    totReadsNum = 0
    print >>sys.stderr, 'Begin evaluation...'
    fp = open(samFileName, 'r')
    
    line = fp.readline()
    while len(line):
        #skip the head 
        if line[0] == '@':
            line = fp.readline()
            continue
        #
        isHit = evalWgsimSeq(line, statDic, optDic)
        if optDic['OutPutUnMapped'] and isHit == const.UHIT:
            print >>fpUnmapped, line 
        elif optDic['OutPutMapped'] and isHit == const.PHIT:
            print >>fpMapped, line
        #print samFormat
        totReadsNum = totReadsNum +1
        if totReadsNum % 100000 == 0:
            print >>sys.stderr, 'eval %u reads...'%(totReadsNum)
        line = fp.readline()
    if totReadsNum % 100000 != 0:
        print >>sys.stderr, 'eval %u reads...'%(totReadsNum)
    
    if(optDic['OutPutUnMapped']):
        fpUnmapped.close()
    if(optDic['OutPutUnMapped']):
        fpMapped.close()
    fp.close()
    
    
    print '**********************************************'
    print 'Evaluation of the alignment result!'
    print 'Total reads Num : %u'%(totReadsNum)
    print "Unmapped reads Num : %u, percent %f"%(statDic['unmappedReadsNum'], (statDic['unmappedReadsNum'] *1.0)/totReadsNum)
    print "Mapped reads Num : %u, percent %f"%(statDic['mappedReadsNum'], (statDic['mappedReadsNum'] * 1.0)/totReadsNum)
    print "Prefect alignment Num : %u, percent %f"%(statDic['perfectAlnNum'], (statDic['perfectAlnNum'] * 1.0)/totReadsNum)
    print '**********************************************'