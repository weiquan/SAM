import re
import sys
import optparse

import const

def isMap(flag):
    if flag & const.FLAG_UNMAP == 0:
        return True
    else:
        return False
def isReverse(flag):
    if flag & const.FLAG_REVERSE != 0:
        return True
    else:
        return False
def inRange(ans, pos, distance):
    if abs(pos-ans) <= distance:
        return True
    else:
        return False

def parseWgsimAnswer(seqName):
    pattern = re.compile(r'(\S+)_(\d+)_(\d+)_')
    match = pattern.search(seqName).groups()
    if match == None:
        print >>sys.err, 'seq ' + seqName + "is not generated by wgsim!"
        exit(1);
    chrome = match[0]
    posLeft = long(match[1])
    posRight = long(match[2])
    return chrome, posLeft, posRight
def evalWgsimSeq(samLine, statDic, d): 
    sam = samLine.split('\t')
    seqName, flag, ref, pos, Mapq, cigar, mateRef, matePos, templateLen, seq, qual = sam[:11]
    flag = int(flag)
    if flag & const.FLAG_UNMAP:
        ref = '*'
        pos = 0
    pos = long(pos)
    Rlen = len(seq)
    answerChr, answerLeftPos, answerRightPos = parseWgsimAnswer(seqName)
    if not isMap(flag):
        statDic['unmappedReadsNum'] += 1
        return const.UHIT 
    else:
        statDic['mappedReadsNum'] += 1
        if ref == answerChr:#same chrome
            if not isReverse(flag):
                if inRange(answerLeftPos, pos, d):
                    statDic['perfectAlnNum'] += 1
                    return const.PHIT
            else:
                if inRange(answerRightPos - Rlen+1, pos, d):
                    statDic['perfectAlnNum'] += 1
                    return const.PHIT
        if len(sam) > 11:
            #print sam
            opts = sam[11:]
            #print opts
            for opt in opts:
                if opt[:5] == 'XA:Z:':
                    alns = opt[5:].strip().split(';')[:-1]
                    #print alns
                    for aln in alns:
                        #print aln
                        chrom, pos, cigar, NM = aln.split(',')
                        pos = long(pos)
                        NM = int(NM)
                        if ref == chrom and pos <0:
                            if inRange(answerRightPos - Rlen+1, pos, d):
                                statDic['similarAlnNum'] += 1
                                return const.GHIT
                        elif ref == chrom:
                            if inRange(answerLeftPos, pos, d):
                                statDic['similarAlnNum'] += 1
                                return const.GHIT
def wgsim_alnEval():

    statDic = {'unmappedReadsNum':0, 'mappedReadsNum':0, 'perfectAlnNum':0, 'similarAlnNum':0}
    usage = "usage: %prog [Options] <file1>"
    parser = optparse.OptionParser(usage)
    parser.add_option('-d', '--diff', action = 'store', type = 'int',  dest='max_diff', help = 'max diff between different SAM', default= 4)
    parser.add_option('-l', '--length', action = 'store', type = 'int',  dest='read_length', help = 'read length', default= 100)
    parser.add_option('--pu', action = 'store_true',  dest='print_unmapped', help = 'print unmapped reads', default= False)
    parser.add_option('--pm', action = 'store_true',  dest='print_mapped', help = 'print mapped reads', default= False)

    #get options
    options, args = parser.parse_args()
    #print options, args
    if options.print_unmapped:
        fpUnmapped = open('unmappedReads.sam', 'w')
    if options.print_mapped:
        fpMapped = open('mappedReads.sam', 'w')
    if len(args) != 1:
        parser.print_help()
        exit(1)
    samFileName = args[0]

    totReadsNum = 0
    print >>sys.stderr, 'Begin evaluation...'
    fp = open(samFileName, 'r')
    
    line = fp.readline().strip()
    while len(line):
        #skip the head 
        if line[0] == '@':
            line = fp.readline().strip()
            continue
        #
        isHit = evalWgsimSeq(line, statDic, options.max_diff)
        if options.print_unmapped and isHit == const.UHIT:
            print >>fpUnmapped, line 
        elif options.print_mapped and (isHit == const.PHIT or isHit == const.GHIT):
            print >>fpMapped, line
        #print samFormat
        totReadsNum = totReadsNum +1
        if totReadsNum % 100000 == 0:
            print >>sys.stderr, 'eval %u reads...'%(totReadsNum)
        line = fp.readline().strip()
    if totReadsNum % 100000 != 0:
        print >>sys.stderr, 'eval %u reads...'%(totReadsNum)
    
    if options.print_unmapped:
        fpUnmapped.close()
    if options.print_mapped:
        fpMapped.close()
    fp.close()
    
    
    print '**********************************************'
    print 'Evaluation of the alignment result!'
    print 'Total reads Num : %u'%(totReadsNum)
    print "Unmapped reads Num : %u, percent %f%%"%(statDic['unmappedReadsNum'], (statDic['unmappedReadsNum'] *1.0)/totReadsNum*100)
    print "Mapped reads Num : %u, percent %f%%"%(statDic['mappedReadsNum'], (statDic['mappedReadsNum'] * 1.0)/totReadsNum*100)
    print "Prefect alignment Num : %u, percent %f%%"%(statDic['perfectAlnNum'], (statDic['perfectAlnNum'] * 1.0)/totReadsNum*100)
    print "Good alignment Num : %u, percent %f%%"%(statDic['similarAlnNum'], (statDic['similarAlnNum'] * 1.0)/totReadsNum*100)
    print '**********************************************'
if __name__ == '__main__':
    wgsim_alnEval()